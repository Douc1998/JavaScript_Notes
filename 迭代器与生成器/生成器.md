# 生成器
## 生成器基础
...
## yield关键字
### yield* 实现递归
**yield\*** 最有用的地方就是实现 **递归** 操作，此时生成器可以 **产生自身** 。如：
```JavaScript
function *nTimes(n){
    if( n < 5 ){
        yield n * (n + 1);
        yield* nTimes(n + 1)
    }
}
for(const x of nTimes(0)){
    console.log(x); // 0=0x1 2=1x2 6=2x3 12=3x4 20=4x5
}
```
既然使用yield\*可以方便地表达递归算法，而 **图结构** 非常适合递归遍历，因此可以用 **yield\*对图进行递归遍历** ，测试该 **图是否连通** 。下面是用yield\*实现图的 **深度遍历**，十分简单：只需要 **从一个结点开始，递归遍历每个结点的邻居结点** ，如果 **没有被访问过** 则加入visited数组中保存。最后 **如果visited数组中包含了所有结点，则说明该图是连通** 的。如下所示：
```JavaScript
// 创建结点Node类
class Node {
    constructor(id) {
        this.id = id;
        this.neighbors = new Set();
    }
    // 结点双向连接
    connect(node) {
        if (node !== this) {
            this.neighbors.add(node);
            node.neighbors.add(this);
        }
    }
}

// 创建随机双向图类
class graph {
    constructor(size) {
        this.nodes = new Set();
        for (let i = 0; i < size; i++) {
            this.nodes.add(new Node(i));
        }
        const threshold = 1 / size; // 概率阈值，是否连接
        for (const x of this.nodes) {
            for (const y of this.nodes) {
                if (Math.random() < threshold) {
                    x.connect(y);
                }
            }
        }
    }
    print() { // 输出随机图
        for (const node of this.nodes) {
            const ids = [...node.neighbors].map((node) => node.id).join(',');
            console.log(node.id.toString() + ':' + ids);
        }
    }
    isConnect(){ // 判断随机图是否连通，即每两个点都可达
        const visitedNodes = new Set();
        function* traverse(nodes){ // 使用递归生成器
            for(const node of nodes){
                if(!visitedNodes.has(node)){
                    yield node; // 遇到yield，暂停函数并保存函数当前状态，可利用.next()或for of继续执行。
                    yield* traverse(node.neighbors);
                }
            }
        }
        const firstNode = this.nodes[Symbol.iterator]().next().value;
        for(const node of traverse([firstNode])){ 
            // 继续开始执行traverse函数，并将node添加入visitedNodes
            visitedNodes.add(node);
        };
        if(visitedNodes.size === this.nodes.size){
            return true
        }else{
            console.log(visitedNodes)
            return false
        }
    }
}

const g = new graph(6);
g.print();
g.isConnect();
```