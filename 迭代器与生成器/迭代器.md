# 迭代器Iterator
## 可迭代对象
并非所有JS内置类型均是 **可迭代对象** ，它们必须拥有 **Iterable** 接口，即可调用工程函数 **\[Symbol.Iterable\]()**生成迭代器进行迭代。  
那么有哪些内置类型实现了Iterable接口呢？如下：
+ String(字符串)
+ Array(数组)
+ Map(映射)
+ Set(集合)
+ arguments对象
+ NodeList等 **DOM对象**
PS：**Object** 和 **Number** 没有Iterable接口。  
如何迭代：调用 **工厂函数生成迭代器** 。如：
```JavaScript
const arr = [1, 2, 3];
const str = 'haha';
const map = new Map().set('a', 1).set('b', 2);
console.log(arr[Symbol.Iterator]()); // ArrayIterator()
console.log(str[Symbol.Iterator]()); // StringIterator()
console.log(map[Symbol.Iterator]()); // MapIterator()
for(const value of arr[Symbol.Iterator]()){
    console.log(value); // 1 2 3
}
```
当然，写代码的时候不一定需要显示地调用工厂函数来生成迭代器。JavaScript中有一些 **原生语句** 会自动在后台调用工厂函数生成迭代器。如：
+ for-of循环
+ 数组解构
+ 扩展操作符
+ Array.from()
+ 创建Set
+ 创建Map
+ yield*操作符( **生成器中使用** )
```JavaScript
const arr = ['douchen', 'lilanxin'];
// for-of循环
for(let value of arr){
    console.log(value); // douchen lilanxin
}
// 数组解构
let [a, b] = arr;
console.log(a, b); // douchen lilanxin
// 扩展操作符
let arrCopy = [...arr];
// Array.from
let arrCopy2 = Array.from(arr);
// new Set()
let set = new Set(arr);
// new Map
let pairs = arr.map((value, index) => [index, value]);
let map = new Map(pairs);
console.log(map); // Map(2) {0 => 'douchen', 1 => 'lilanxin'}
// yield* 见 "生成器.md"
```
## 迭代器API
### next()
...
### return()
...
